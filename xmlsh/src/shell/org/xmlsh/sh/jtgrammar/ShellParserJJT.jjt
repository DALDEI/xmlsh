 /**
 * JavaCC file
 */
options
{
  JDK_VERSION = "1.7";
  STATIC = false;
  OUTPUT_DIRECTORY="../../../../../generatedjt/org/xmlsh/sh/grammarjt";

}


PARSER_BEGIN(ShellParserJJT)

package org.xmlsh.sh.grammarjt;
import org.xmlsh.sh.core.*;
import java.io.PrintWriter;
import java.util.ArrayList;
import org.xmlsh.core.XEnvironment;

public class ShellParserJJT
{


  /** Main entry point. */
  public static void main(String args[]) {
    System.out.println("Reading from standard input...");
    ShellParserJJT t = new ShellParserJJT(System.in);
    try {
      SimpleNode n =  t.Start();
      n.dump("");
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }  
    
}

PARSER_END(ShellParserJJT)


/*
 LEXICAL STATES:

 
 <DEFAULT> General parsing state - should only derive tokesn from LEX state

 
*/


< DEFAULT >
SPECIAL_TOKEN :{< WHITESPACE :  < _WS > >}


/* COMMENTS */

SPECIAL_TOKEN :
{
   <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])*>
}

<DEFAULT>
TOKEN :
{
  <NL : "\n" | "\r" | "\r\n" > 
    : DEFAULT
}




// Abstract tokens that are only switched to never actually matched
< NEVER >
TOKEN :
{
  < BACKTICK2 : "`" >
 | < MRBRACE : "}" > : DEFAULT 
//| 
 // < RPAREN : ")" >
}

// Global patterns 
<DEFAULT,IN_VAR_EXPANSION>
TOKEN :
{
    < #_WS :  ( " " | "\r" | "\t" )+ >
|   <#_LETTER:   ["A"-"Z","_","a"-"z","\u00a2"-"\u00a5","\u00aa","\u00b5","\u00ba","\u00c0"-"\u00d6","\u00d8"-"\u00f6","\u00f8"-"\u021f","\u0222"-"\u0233","\u0250"-"\u02ad","\u02b0"-"\u02b8","\u02bb"-"\u02c1","\u02d0"-"\u02d1","\u02e0"-"\u02e4","\u02ee","\u037a","\u0386","\u0388"-"\u038a","\u038c","\u038e"-"\u03a1","\u03a3"-"\u03ce","\u03d0"-"\u03d7","\u03da"-"\u03f3","\u0400"-"\u0481","\u048c"-"\u04c4","\u04c7"-"\u04c8","\u04cb"-"\u04cc","\u04d0"-"\u04f5","\u04f8"-"\u04f9","\u0531"-"\u0556","\u0559","\u0561"-"\u0587","\u05d0"-"\u05ea","\u05f0"-"\u05f2","\u0621"-"\u063a","\u0640"-"\u064a","\u0671"-"\u06d3","\u06d5","\u06e5"-"\u06e6","\u06fa"-"\u06fc","\u0710","\u0712"-"\u072c","\u0780"-"\u07a5","\u0905"-"\u0939","\u093d","\u0950","\u0958"-"\u0961","\u0985"-"\u098c","\u098f"-"\u0990","\u0993"-"\u09a8","\u09aa"-"\u09b0","\u09b2","\u09b6"-"\u09b9","\u09dc"-"\u09dd","\u09df"-"\u09e1","\u09f0"-"\u09f3","\u0a05"-"\u0a0a","\u0a0f"-"\u0a10","\u0a13"-"\u0a28","\u0a2a"-"\u0a30","\u0a32"-"\u0a33","\u0a35"-"\u0a36","\u0a38"-"\u0a39","\u0a59"-"\u0a5c","\u0a5e","\u0a72"-"\u0a74","\u0a85"-"\u0a8b","\u0a8d","\u0a8f"-"\u0a91","\u0a93"-"\u0aa8","\u0aaa"-"\u0ab0","\u0ab2"-"\u0ab3","\u0ab5"-"\u0ab9","\u0abd","\u0ad0","\u0ae0","\u0b05"-"\u0b0c","\u0b0f"-"\u0b10","\u0b13"-"\u0b28","\u0b2a"-"\u0b30","\u0b32"-"\u0b33","\u0b36"-"\u0b39","\u0b3d","\u0b5c"-"\u0b5d","\u0b5f"-"\u0b61","\u0b85"-"\u0b8a","\u0b8e"-"\u0b90","\u0b92"-"\u0b95","\u0b99"-"\u0b9a","\u0b9c","\u0b9e"-"\u0b9f","\u0ba3"-"\u0ba4","\u0ba8"-"\u0baa","\u0bae"-"\u0bb5","\u0bb7"-"\u0bb9","\u0c05"-"\u0c0c","\u0c0e"-"\u0c10","\u0c12"-"\u0c28","\u0c2a"-"\u0c33","\u0c35"-"\u0c39","\u0c60"-"\u0c61","\u0c85"-"\u0c8c","\u0c8e"-"\u0c90","\u0c92"-"\u0ca8","\u0caa"-"\u0cb3","\u0cb5"-"\u0cb9","\u0cde","\u0ce0"-"\u0ce1","\u0d05"-"\u0d0c","\u0d0e"-"\u0d10","\u0d12"-"\u0d28","\u0d2a"-"\u0d39","\u0d60"-"\u0d61","\u0d85"-"\u0d96","\u0d9a"-"\u0db1","\u0db3"-"\u0dbb","\u0dbd","\u0dc0"-"\u0dc6","\u0e01"-"\u0e30","\u0e32"-"\u0e33","\u0e3f"-"\u0e46","\u0e81"-"\u0e82","\u0e84","\u0e87"-"\u0e88","\u0e8a","\u0e8d","\u0e94"-"\u0e97","\u0e99"-"\u0e9f","\u0ea1"-"\u0ea3","\u0ea5","\u0ea7","\u0eaa"-"\u0eab","\u0ead"-"\u0eb0","\u0eb2"-"\u0eb3","\u0ebd","\u0ec0"-"\u0ec4","\u0ec6","\u0edc"-"\u0edd","\u0f00","\u0f40"-"\u0f47","\u0f49"-"\u0f6a","\u0f88"-"\u0f8b","\u1000"-"\u1021","\u1023"-"\u1027","\u1029"-"\u102a","\u1050"-"\u1055","\u10a0"-"\u10c5","\u10d0"-"\u10f6","\u1100"-"\u1159","\u115f"-"\u11a2","\u11a8"-"\u11f9","\u1200"-"\u1206","\u1208"-"\u1246","\u1248","\u124a"-"\u124d","\u1250"-"\u1256","\u1258","\u125a"-"\u125d","\u1260"-"\u1286","\u1288","\u128a"-"\u128d","\u1290"-"\u12ae","\u12b0","\u12b2"-"\u12b5","\u12b8"-"\u12be","\u12c0","\u12c2"-"\u12c5","\u12c8"-"\u12ce","\u12d0"-"\u12d6","\u12d8"-"\u12ee","\u12f0"-"\u130e","\u1310","\u1312"-"\u1315","\u1318"-"\u131e","\u1320"-"\u1346","\u1348"-"\u135a","\u13a0"-"\u13f4","\u1401"-"\u166c","\u166f"-"\u1676","\u1681"-"\u169a","\u16a0"-"\u16ea","\u1780"-"\u17b3","\u17db","\u1820"-"\u1877","\u1880"-"\u18a8","\u1e00"-"\u1e9b","\u1ea0"-"\u1ef9","\u1f00"-"\u1f15","\u1f18"-"\u1f1d","\u1f20"-"\u1f45","\u1f48"-"\u1f4d","\u1f50"-"\u1f57","\u1f59","\u1f5b","\u1f5d","\u1f5f"-"\u1f7d","\u1f80"-"\u1fb4","\u1fb6"-"\u1fbc","\u1fbe","\u1fc2"-"\u1fc4","\u1fc6"-"\u1fcc","\u1fd0"-"\u1fd3","\u1fd6"-"\u1fdb","\u1fe0"-"\u1fec","\u1ff2"-"\u1ff4","\u1ff6"-"\u1ffc","\u203f"-"\u2040","\u207f","\u20a0"-"\u20af","\u2102","\u2107","\u210a"-"\u2113","\u2115","\u2119"-"\u211d","\u2124","\u2126","\u2128","\u212a"-"\u212d","\u212f"-"\u2131","\u2133"-"\u2139","\u2160"-"\u2183","\u3005"-"\u3007","\u3021"-"\u3029","\u3031"-"\u3035","\u3038"-"\u303a","\u3041"-"\u3094","\u309d"-"\u309e","\u30a1"-"\u30fe","\u3105"-"\u312c","\u3131"-"\u318e","\u31a0"-"\u31b7","\u3400"-"\u4db5","\u4e00"-"\u9fa5","\ua000"-"\ua48c","\uac00"-"\ud7a3","\uf900"-"\ufa2d","\ufb00"-"\ufb06","\ufb13"-"\ufb17","\ufb1d","\ufb1f"-"\ufb28","\ufb2a"-"\ufb36","\ufb38"-"\ufb3c","\ufb3e","\ufb40"-"\ufb41","\ufb43"-"\ufb44","\ufb46"-"\ufbb1","\ufbd3"-"\ufd3d","\ufd50"-"\ufd8f","\ufd92"-"\ufdc7","\ufdf0"-"\ufdfb","\ufe33"-"\ufe34","\ufe4d"-"\ufe4f","\ufe69","\ufe70"-"\ufe72","\ufe74","\ufe76"-"\ufefc","\uff04","\uff21"-"\uff3a","\uff3f","\uff41"-"\uff5a","\uff65"-"\uffbe","\uffc2"-"\uffc7","\uffca"-"\uffcf","\uffd2"-"\uffd7","\uffda"-"\uffdc","\uffe0"-"\uffe1","\uffe5"-"\uffe6"]>
|   <#_DIGIT:   ["0"-"9"] >
|   <#_NUMBER:  "0" | (< _DIGIT >)+ >
|   <#_ALPHA:   ["A"-"Z","a"-"z","\u00a2"-"\u00a5","\u00aa","\u00b5","\u00ba","\u00c0"-"\u00d6","\u00d8"-"\u00f6","\u00f8"-"\u021f","\u0222"-"\u0233","\u0250"-"\u02ad","\u02b0"-"\u02b8","\u02bb"-"\u02c1","\u02d0"-"\u02d1","\u02e0"-"\u02e4","\u02ee","\u037a","\u0386","\u0388"-"\u038a","\u038c","\u038e"-"\u03a1","\u03a3"-"\u03ce","\u03d0"-"\u03d7","\u03da"-"\u03f3","\u0400"-"\u0481","\u048c"-"\u04c4","\u04c7"-"\u04c8","\u04cb"-"\u04cc","\u04d0"-"\u04f5","\u04f8"-"\u04f9","\u0531"-"\u0556","\u0559","\u0561"-"\u0587","\u05d0"-"\u05ea","\u05f0"-"\u05f2","\u0621"-"\u063a","\u0640"-"\u064a","\u0671"-"\u06d3","\u06d5","\u06e5"-"\u06e6","\u06fa"-"\u06fc","\u0710","\u0712"-"\u072c","\u0780"-"\u07a5","\u0905"-"\u0939","\u093d","\u0950","\u0958"-"\u0961","\u0985"-"\u098c","\u098f"-"\u0990","\u0993"-"\u09a8","\u09aa"-"\u09b0","\u09b2","\u09b6"-"\u09b9","\u09dc"-"\u09dd","\u09df"-"\u09e1","\u09f0"-"\u09f3","\u0a05"-"\u0a0a","\u0a0f"-"\u0a10","\u0a13"-"\u0a28","\u0a2a"-"\u0a30","\u0a32"-"\u0a33","\u0a35"-"\u0a36","\u0a38"-"\u0a39","\u0a59"-"\u0a5c","\u0a5e","\u0a72"-"\u0a74","\u0a85"-"\u0a8b","\u0a8d","\u0a8f"-"\u0a91","\u0a93"-"\u0aa8","\u0aaa"-"\u0ab0","\u0ab2"-"\u0ab3","\u0ab5"-"\u0ab9","\u0abd","\u0ad0","\u0ae0","\u0b05"-"\u0b0c","\u0b0f"-"\u0b10","\u0b13"-"\u0b28","\u0b2a"-"\u0b30","\u0b32"-"\u0b33","\u0b36"-"\u0b39","\u0b3d","\u0b5c"-"\u0b5d","\u0b5f"-"\u0b61","\u0b85"-"\u0b8a","\u0b8e"-"\u0b90","\u0b92"-"\u0b95","\u0b99"-"\u0b9a","\u0b9c","\u0b9e"-"\u0b9f","\u0ba3"-"\u0ba4","\u0ba8"-"\u0baa","\u0bae"-"\u0bb5","\u0bb7"-"\u0bb9","\u0c05"-"\u0c0c","\u0c0e"-"\u0c10","\u0c12"-"\u0c28","\u0c2a"-"\u0c33","\u0c35"-"\u0c39","\u0c60"-"\u0c61","\u0c85"-"\u0c8c","\u0c8e"-"\u0c90","\u0c92"-"\u0ca8","\u0caa"-"\u0cb3","\u0cb5"-"\u0cb9","\u0cde","\u0ce0"-"\u0ce1","\u0d05"-"\u0d0c","\u0d0e"-"\u0d10","\u0d12"-"\u0d28","\u0d2a"-"\u0d39","\u0d60"-"\u0d61","\u0d85"-"\u0d96","\u0d9a"-"\u0db1","\u0db3"-"\u0dbb","\u0dbd","\u0dc0"-"\u0dc6","\u0e01"-"\u0e30","\u0e32"-"\u0e33","\u0e3f"-"\u0e46","\u0e81"-"\u0e82","\u0e84","\u0e87"-"\u0e88","\u0e8a","\u0e8d","\u0e94"-"\u0e97","\u0e99"-"\u0e9f","\u0ea1"-"\u0ea3","\u0ea5","\u0ea7","\u0eaa"-"\u0eab","\u0ead"-"\u0eb0","\u0eb2"-"\u0eb3","\u0ebd","\u0ec0"-"\u0ec4","\u0ec6","\u0edc"-"\u0edd","\u0f00","\u0f40"-"\u0f47","\u0f49"-"\u0f6a","\u0f88"-"\u0f8b","\u1000"-"\u1021","\u1023"-"\u1027","\u1029"-"\u102a","\u1050"-"\u1055","\u10a0"-"\u10c5","\u10d0"-"\u10f6","\u1100"-"\u1159","\u115f"-"\u11a2","\u11a8"-"\u11f9","\u1200"-"\u1206","\u1208"-"\u1246","\u1248","\u124a"-"\u124d","\u1250"-"\u1256","\u1258","\u125a"-"\u125d","\u1260"-"\u1286","\u1288","\u128a"-"\u128d","\u1290"-"\u12ae","\u12b0","\u12b2"-"\u12b5","\u12b8"-"\u12be","\u12c0","\u12c2"-"\u12c5","\u12c8"-"\u12ce","\u12d0"-"\u12d6","\u12d8"-"\u12ee","\u12f0"-"\u130e","\u1310","\u1312"-"\u1315","\u1318"-"\u131e","\u1320"-"\u1346","\u1348"-"\u135a","\u13a0"-"\u13f4","\u1401"-"\u166c","\u166f"-"\u1676","\u1681"-"\u169a","\u16a0"-"\u16ea","\u1780"-"\u17b3","\u17db","\u1820"-"\u1877","\u1880"-"\u18a8","\u1e00"-"\u1e9b","\u1ea0"-"\u1ef9","\u1f00"-"\u1f15","\u1f18"-"\u1f1d","\u1f20"-"\u1f45","\u1f48"-"\u1f4d","\u1f50"-"\u1f57","\u1f59","\u1f5b","\u1f5d","\u1f5f"-"\u1f7d","\u1f80"-"\u1fb4","\u1fb6"-"\u1fbc","\u1fbe","\u1fc2"-"\u1fc4","\u1fc6"-"\u1fcc","\u1fd0"-"\u1fd3","\u1fd6"-"\u1fdb","\u1fe0"-"\u1fec","\u1ff2"-"\u1ff4","\u1ff6"-"\u1ffc","\u203f"-"\u2040","\u207f","\u20a0"-"\u20af","\u2102","\u2107","\u210a"-"\u2113","\u2115","\u2119"-"\u211d","\u2124","\u2126","\u2128","\u212a"-"\u212d","\u212f"-"\u2131","\u2133"-"\u2139","\u2160"-"\u2183","\u3005"-"\u3007","\u3021"-"\u3029","\u3031"-"\u3035","\u3038"-"\u303a","\u3041"-"\u3094","\u309d"-"\u309e","\u30a1"-"\u30fe","\u3105"-"\u312c","\u3131"-"\u318e","\u31a0"-"\u31b7","\u3400"-"\u4db5","\u4e00"-"\u9fa5","\ua000"-"\ua48c","\uac00"-"\ud7a3","\uf900"-"\ufa2d","\ufb00"-"\ufb06","\ufb13"-"\ufb17","\ufb1d","\ufb1f"-"\ufb28","\ufb2a"-"\ufb36","\ufb38"-"\ufb3c","\ufb3e","\ufb40"-"\ufb41","\ufb43"-"\ufb44","\ufb46"-"\ufbb1","\ufbd3"-"\ufd3d","\ufd50"-"\ufd8f","\ufd92"-"\ufdc7","\ufdf0"-"\ufdfb","\ufe33"-"\ufe34","\ufe4d"-"\ufe4f","\ufe69","\ufe70"-"\ufe72","\ufe74","\ufe76"-"\ufefc","\uff04","\uff21"-"\uff3a","\uff3f","\uff41"-"\uff5a","\uff65"-"\uffbe","\uffc2"-"\uffc7","\uffca"-"\uffcf","\uffd2"-"\uffd7","\uffda"-"\uffdc","\uffe0"-"\uffe1","\uffe5"-"\uffe6"]>
|   <#_ID :      < _LETTER > ( < _LETTER > | < _NUMBER > )* >
|   <#_ID2 :     < _LETTER > ( < _LETTER > | < _NUMBER > | "-" )* >
|   <#_VARNAME : < _ID >>
|   <#_NS      : ( ([ "A"-"Z", "a"-"z", "_", "0"-"9", "-" ])+ ":") >
|   <#_POSVAR  : < _NUMBER > >
}

// Patterns
TOKEN :
{
    < #_WILD_PART :  ( [ "*" , "?" ])  |  (  "[" ( ( ~[ "[" ,  " " , "\t" , "\r" , "\t" , "\f"  , "]" , "\n" ,  "]" , "#" ] ) | ("\\[")  )+ "]" ) >
|   < #_STRING_LITERAL : (
       < _STRING_LITERAL1 > | < _STRING_LITERAL2 >
     ) >|   < #_STRING_LITERAL1 :
    "\""
    (
      (~[ "\"", "\\" ])
    |
      (
       < _ESCAPED >
      )
    )*
    "\"" 
    >
| 
  < #_STRING_LITERAL2 :
    "\'"
    (
      (~[ "'" ])
    )*
    "\'" 
    >
|  < #_ESCAPED : "\\" ~[ ] >


|  < VAR_EXPANSION1 :
     "$" < _VARNAME >
  |  "$" < _POSVAR >
  | "$" [ "#", "?", "*", "@", "$", "!" ]
  | "$" < _NUMBER > 
    >

}

/* 
 * Complex variable expressions 
 * Start with ${
 */

MORE :  
{ 
    < "${"   ( <_VARNAME> | <_POSVAR> )  > : IN_VAR_EXPANSION
|   < "${#"  ( <_VARNAME> | <_POSVAR> )  > : IN_VAR_EXPANSION
   
}
< IN_VAR_EXPANSION > 
TOKEN : 
{
 < VAR_EXPANSION2 :  "}" > : DEFAULT 
}   


// TODO: better filtering 
<IN_VAR_EXPANSION>
MORE :
{
  < ~[] >
}

TOKEN :{  < SEMI : ";" >
| < AMP  : "&" >|  < AND_IF : "&&" > | < OR_IF : "||" > |  < DGREAT : ">>" >
| < DSEMI : ";;" >| < CLOBBER : ">|" >}

/*
 * Words which are possibly resserved - catch first
 * If its an exact match and no longer then these will be triggered first
 */
TOKEN :
{  < CATCH : "catch" >
| < FOR : "for" > 
| < IF : "if" >| < ELIF : "elif" >| < THEN : "then" >| < ELSE : "else" >| < FI : "fi" >| < DO : "do" > | < CASE : "case" >| < WHILE : "while" >| < UNTIL : "until" >| < TRY : "try" > | < ESAC: "esac" > | < FINALLY : "finally" >
| < RETURN : "return" > | < DONE : "done" >
| < IN   : "in" >
| < FUNCTION : "function" >
| < LOCAL : "local" >
| < NLESSANDN :  < _DIGITS > "<&" < _DIGITS > > 
| < NGTANDN   :  < _DIGITS > ">&" < _DIGITS > > 
| < NLTN      :  < _DIGITS > "<" < _DIGITS >  > 
| < NGTN      :  < _DIGITS > ">" < _DIGITS >  > 
| < NGTGT     :  < _DIGITS > ">>" > 
| < NGT       :  < _DIGITS > ">" > 
| < NLT       :  < _DIGITS > "<" >
| < PLESSANDP :  < _PORTWORD > "<&" < _PORTWORD > > 
| < PGTANDP  :   < _PORTWORD > ">&" < _PORTWORD > > 
| < PLTP      :  < _PORTWORD > "<" < _PORTWORD >  > 
| < PGTP      :  < _PORTWORD > ">" < _PORTWORD >  > 
| < PGTGP     :  < _PORTWORD > ">>" < _PORTWORD > > 
| < PGT       :  < _PORTWORD > ">" > 
| < PLT       :   < _PORTWORD > "<" >
| < GTP       :   ">" < _PORTWORD > >
| < LTP       :   "<" < _PORTWORD > >
| < GT        : ">" >
| < LT        : "<" > 
| < #_DIGITS  : [ "1"-"2" ] >
| < #_PORTWORD :  "("  < _ID >   ")" >
| < #_WORD_SPECIAL :     ( "[" | "]" | "$" | "," ) >
| < WORD_PUNC :     ( "=" ) >

// Word Expressions that shold be tokenized together


| < PDLESSMINUS : < _PORTWORD > "<<-" >
|  < PDLESS : < _PORTWORD > "<<" >
|  < DLESSMINUS : "<<-" >
|  < DLESS : "<<" >
| < LBRACE : "{" > 
| < LPAREN : "(" >
| < RBRACE : "}" > 
| < RPAREN : ")" >| < PIPE : "|" > | < BIGQUOTE : "<{{" >  
  /*
   * Order names by most specific (widest set) to least specific
   * of the same length
   */
  
  
|  < SIMPLE_NAME  : < _ID > >   
|  < NAME :  <_ID2>  > 
|  < SIMPLE_NS_NAME : (<_NS>) <_ID> >
|  < NS_NAME :  (<_NS> ) <_ID2>  >  

   

  
  
  // Word with extra stuff allowed 
 | < WORD_TOKEN :
   (
    (
    ~[ "|" , "&" , "<" , ">" , "," , "(" , ")" , "$" , "`" , "\\" , "\"" , "'" , " " , "\t" , "\n" , "\r" , "=" , ";","#" , "{" , "}" ] 
    | < _ESCAPED >
    | < _STRING_LITERAL >
    )+ | 
    < _WORD_SPECIAL > 
    | <WORD_PUNC> )
  >


|   < XEXPR : "<[" >

|   < VAR_SUBPROC :    "$("  | "$<("     > 
|   < VAR_SUBPROC_FILE :    "$(<"  | "$<(<"     >
|   < BACKTICK1 : "`" >|  < ASSIGN_WORD_SEQ :
    (
        < _VARNAME > "=("
    ) >| < ASSIGN_WORDPE_SEQ : < _VARNAME > "+=(" > 
| < ASSIGN_WORDPE : < _VARNAME > "+=" > 
}


/*
 *
 * Productions
 */

SimpleNode Start() : {}
{
  command_line()
  { return jjtThis; }
}


void eol() :{
}
{  < NL >
  
}  

void eol_or_eof() :
{
}
 {
  ( < NL > | < EOF > )
}

void eol_or_semi() :
{
}
 {
  ( < NL > | < SEMI > )
}



void script() :{}{ 
		 < EOF > 	|
	  compound_list() < EOF >}void command_line() :{}{
   eol()
| < EOF >
| 
     complete_command() eol_or_eof()

    }void complete_command() :{
}{   list()}void and_or() :{}{   pipeline()  (
     andor_if() linebreak()  pipeline()  )*}void andor_if() :{}{   (    < AND_IF > |    < OR_IF >
  )}void pipeline() :{}{   LOOKAHEAD( 1 , <WORD_TOKEN> , {
    getToken(1).image.equals("!") })
     <WORD_TOKEN>   pipe_sequence()|   pipe_sequence()
}void pipe_sequence() :{}{   command()  (    < PIPE > linebreak()  command()  )*}


void command() :{  CompoundCommand c;  
}{

 LOOKAHEAD( 1 , compound_command_lookahead() )  compound_command()   [     redirect_list()  ]| 
  LOOKAHEAD( 1 , { getToken(1).kind == FUNCTION  })
   function_declaration()
|
    LOOKAHEAD( 2 , function_declaration_lookahead()  )
    function_declaration()
|
  simple_command()


}

// Detect the start of a compound command void compound_command_lookahead() :
{
}
{
   "{" 
|  "(" 
|  "for" 
|  "case" 
|  "if" 
| "try"
| "while"
| "until"
}


void compound_command() :{ }{   brace_group()|  subshell()|  for_clause() |  case_clause()|  if_clause()|  trycatch_clause()|  while_clause()|  until_clause()}void subshell() :{ }{  < LPAREN >  compound_list() < RPAREN >}

/*
 * List vs term()
 *    The term "compound-list" is derived from the grammar in Shell Grammar;
 *  it is equivalent to a sequence of lists, separated by <newline>s,
 *  that can be preceded or followed by an arbitrary number of <newline>s.
 */
 

void compound_list() :{}{

  ( < NL > ) *    
   term()

  ( < NL > ) *

          
  
}
void list() :
{
 
 
 
}
{
   and_or()
  (
    LOOKAHEAD( separator_op() term_stop_lookahead() )  separator_op()
  | LOOKAHEAD( separator_op() )   separator_op()
    list2()
  ) ?
}


void list2() :
{
 
 
}
{
  <EOF>
|
   list()
  (
       LOOKAHEAD( separator_op() term_stop_lookahead() )  separator_op()
  |   LOOKAHEAD( separator_op() )   separator_op()
      list2(  )
  ) ?
}


/*
 * term() only occurs in compound_list
 * To detect if the separator continues the term or ends it .
 * the following next tokens will terminate term()
 *
 * Implement term as a sequence of lists 
 */
void term() :{ 
  }{   list()

  (    	LOOKAHEAD( (< NL >)+ term_stop_lookahead() ) (< NL >)+
     |   
	    (< NL >)+          term2(  ) 
  ) ?

}


void term2() :
{
 
}
{
   list()
  (
    LOOKAHEAD( (< NL >)+ term_stop_lookahead() ) (< NL >)+
  |    
	    (< NL >)+
          term2(   ) 
  ) ?
}


/*
 * Used ONLY to determine if to go into an and_or from a term
 * Do this by terminating on
 * ;; ) } else then do done elif fi 
 */
void term_stop_lookahead() :
{}
{
    
   (        ";;" |  <RPAREN> | <MRBRACE> | "else" | "then" | "do" | "done"  | "fi" | "elif" | <NL >)
}
void for_clause() :{     }{  "for" varname() linebreak()  (";" |
  (    "in" (
       sequential_sep()
       | for_in_words() sequential_sep()
     ) 
  )?)   do_group()}

void for_in_words() :
{ 
 
}
{    wordlist()}
void trycatch_clause() :{  }{  "try" linebreak() < LBRACE >  compound_list() < MRBRACE > linebreak()   "catch"  varname()  linebreak() < LBRACE >  compound_list() < MRBRACE >   [ "finally" linebreak() < LBRACE >  compound_list() < MRBRACE > ]}


void varname_lookahead() : 
{}
{
   [ LOOKAHEAD(1 ,reserved_lookahead() ) reserved()  
   | <SIMPLE_NAME> ] 

}

// Any word that passes the varname testvoid varname() :{ }{  LOOKAHEAD(1,reserved()) reserved()
| < SIMPLE_NAME >}
void reserved_lookahead() :
{}
{
   LOOKAHEAD( 1 , reserved() )
   reserved()
   
}


void reserved() :
{
}
{(  < CATCH >
| < FOR >
| < IF >
| < ELIF >
| < THEN >
| < ELSE >
| < FI >
| < DO >
| < CASE >
| < WHILE >
| < UNTIL >
| < TRY >
| < ESAC >
| < FINALLY >
| < RETURN >
| < DONE >
| < IN > 
| < LOCAL > 
| < FUNCTION > )

}



/*
 * Word expr used in case patterns
 */
void pattern_word() :{ }{
  LOOKAHEAD(1,reserved()) reserved()
|  (   <NAME>  | <NS_NAME> | <SIMPLE_NAME > | <SIMPLE_NS_NAME>  | 
   < WORD_TOKEN >
  | < XEXPR >  | < BIGQUOTE >
  )  }void wordlist() :{  }{  (     expr()  )+}void case_clause() :{  
 }{   "case"  expr() "in"
  linebreak()   case_list() }void case_list() :{  }{
   (
     LOOKAHEAD( 1 , "esac"  ) "esac" 
  |     
      case_item()   ) *}

void case_item() :{   }{  [ < LPAREN > ]  pattern()  < RPAREN >  linebreak() [  compound_list() ]  < DSEMI > linebreak()}void pattern() :{  }{   pattern_word()  (    < PIPE >  pattern_word()  )*}void if_clause() :{   }{  "if"  compound_list() "then"  compound_list()  [    LOOKAHEAD(1, ( < ELIF > | < ELSE > ) )     else_part()  ]  "fi"}void else_part() :{ }{  "elif"  compound_list() "then"  compound_list() [  else_part() ]|   "else"  compound_list()}void while_clause() :{}{  "while"  compound_list()  do_group()}void until_clause() :{ }{  "until"  compound_list()  do_group()}
void return_stmt() :
{
 
 
 
}
{
  "return"

  [ expr() ]
}


/*
 * Single word that can be arguments to commands or functions 
 */


void expr() :
{ 
 
 
 
 
}
{
   < LBRACE >  comma_expr() < MRBRACE >
|  
  LOOKAHEAD(2, < NS_NAME > | <SIMPLE_NS_NAME >| <NAME >|<SIMPLE_NAME > , 
       {  getToken(2).kind == LPAREN }  )
  ( < NS_NAME >| <SIMPLE_NS_NAME >| <NAME >|<SIMPLE_NAME > ) 
  
  <LPAREN>  function_args()

|

  word_or_name()
|
  (
     < XEXPR >
  |  < BIGQUOTE >
  )
|  < VAR_SUBPROC >  compound_list() < RPAREN >
|  < VAR_SUBPROC_FILE >  filename() < RPAREN >
| < BACKTICK1 >  compound_list() < BACKTICK2 >
  
}

void comma_expr():
{
 
 
}
{
   expr() 
   
   ( LOOKAHEAD( 1 , <WORD_TOKEN>, { getToken(1).kind == WORD_TOKEN && getToken(1).image.equals(",")} )
     <WORD_TOKEN>  expr() 
      )*
}



void function_declaration() :{}{
  (   "function" name()  [ <LPAREN> <RPAREN> ]     |  name() <LPAREN> <RPAREN> )  linebreak()  function_body() }

// Name or SimpleName  (no NS)
void name() :
{}
{
  (  <NAME> | <SIMPLE_NAME> )
}



void function_declaration_lookahead() :
{}
{
  LOOKAHEAD( 2 , name() <LPAREN> , {  
                                      getToken(2).kind == LPAREN } )
  name() <LPAREN> 
 }

void function_body() :{ }{   compound_command()}void brace_group() :{ }{  < LBRACE >  compound_list() < MRBRACE >}void do_group() :{ }{  "do"  compound_list() "done"}void simple_command() :{ 
 
  
 
 
 
 
}{
  // Special case for return statement - bad desig
   LOOKAHEAD( 1, <RETURN >  ) return_stmt()
|     cmd_prefix()
  [     cmd_name_word()  ]   cmd_suffix()
  | 
    cmd_name_word()   cmd_suffix()}

void cmd_arg_words() :
{
 
 
}
{
  (
       expr()
  )*
}
  // A word that can be a command name
void cmd_name_word() :{ 
 
}
{
   cmd_name()}  void cmd_name() :{
 
 }{

  LOOKAHEAD(1,reserved()) reserved()
 |  ( <NAME> | <SIMPLE_NAME> | <NS_NAME> < SIMPLE_NS_NAME > | < WORD_TOKEN > | < VAR_EXPANSION1 > | <VAR_EXPANSION2 > )
     (
        LOOKAHEAD( 1 , reserved() ) reserved()
         | 
        LOOKAHEAD( 1,  ( <NAME> | <SIMPLE_NAME> |   < WORD_TOKEN > | 
	       < VAR_EXPANSION1 > | <VAR_EXPANSION2 > ) , 
	       {   getToken(1).specialToken == null   } )	           cmd_name()  )?
}

//  
void word_or_name() :
{
 
 
}
{  LOOKAHEAD(1,reserved()) reserved() | (  <WORD_PUNC> |  < VAR_EXPANSION1 > | < VAR_EXPANSION2 >  | <WORD_TOKEN > |< NS_NAME > | <SIMPLE_NS_NAME >| <NAME >|<SIMPLE_NAME > )
      (  LOOKAHEAD( 1 , (<WORD_PUNC> | < VAR_EXPANSION1 > | < VAR_EXPANSION2 >  | <WORD_TOKEN > |< NS_NAME > | <SIMPLE_NS_NAME >| <NAME >|<SIMPLE_NAME >  ),
            { getToken(1).specialToken == null } )     
               word_or_name() )?
}
void function_args() :{  }{
   ( 
   
    (<NL>)+ 
   |
    <RPAREN> 
    
    |  
    
      expr()   )*}
void cmd_prefix() :{  }{  (     assign()  )+ }

void assign() :{}{

  LOOKAHEAD( 2 , <LOCAL> <SIMPLE_NAME> )  <LOCAL>  < SIMPLE_NAME > 
|   [ <LOCAL> ] 
   (
	    < ASSIGN_WORDPE >  expr()	| 	     < ASSIGN_WORD_SEQ >  cmd_words() <RPAREN >	| 	   < ASSIGN_WORDPE_SEQ >  cmd_words() < RPAREN >	| 
	
	  LOOKAHEAD( 2 , varname_lookahead()  "="  ,
                   { (getToken(1).kind == SIMPLE_NAME )
              } )  
	    varname()  "=" [  expr() ]
	  
|  	  LOOKAHEAD( 2 , varname_lookahead() "=" )  
           varname()  "="
	  
  )}

void cmd_words() :{  }{  (    (       expr()    )  )*}



void cmd_suffix() :{   }{  (       expr()  )*  (     io_redirect()  )*}
void redirect_list() :{  }{  (     io_redirect()  )+}void io_redirect() :{  
 
 }{  /* lookahead enough to disambiguate the next 2 rules */

 (
      < NLESSANDN > |
       <  NGTANDN > |
       < NLTN > |
       <  NGTN >
    )
| (
       <  NGT > |
       < NLT > |
       <  NGTGT > |
       < LT > |
      < GT > |
      < DGREAT > |
      < CLOBBER > 
    )  filename_word()

| (
      < PLESSANDP > |
      < PGTANDP >    |
      < PLTP > |
      < PGTP > |
      < PGTGP > |
      < GTP > |
      < LTP > )
| (
     <PGT > |
     <PLT > )
      filename_word()
|  < PDLESS > 
| 
   < DLESSMINUS >
| 
   < PDLESSMINUS >
|
  < DLESS > 
}

void filename() :{ }{
  word_or_name()}void filename_word() :{    }{  filename()|  < VAR_SUBPROC >  compound_list() < RPAREN >|  < VAR_SUBPROC_FILE >  filename() < RPAREN >|     < LBRACE >   word_or_name()   < MRBRACE >}void separator_op() :{}{  ( < AMP > | < SEMI > )
}


// One or more newlines 
void newline_list() :
{}
{
   (
     < NL >) +
}

// Optional newline 
void linebreak() :
{}
{
  ( < NL >)*
}

/*
 * occurs ONLY in complete command (trailing) or between lists (in terms)
 */
void separator() :{ }{   separator_op() linebreak()| 
    newline_list()
}void sequential_sep() :{}{  
  < SEMI > linebreak() | newline_list()}


